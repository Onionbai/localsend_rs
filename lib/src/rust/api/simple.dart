// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.5.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../core/model.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'simple.freezed.dart';

Stream<LogEntry> createLogStream({dynamic hint}) =>
    RustLib.instance.api.createLogStream(hint: hint);

Future<void> rustSetUp({required bool isDebug, dynamic hint}) =>
    RustLib.instance.api.rustSetUp(isDebug: isDebug, hint: hint);

Future<void> initServer({required DeviceConfig device, dynamic hint}) =>
    RustLib.instance.api.initServer(device: device, hint: hint);

Future<void> startServer({required ServerConfig config, dynamic hint}) =>
    RustLib.instance.api.startServer(config: config, hint: hint);

Future<void> stopServer({dynamic hint}) =>
    RustLib.instance.api.stopServer(hint: hint);

Future<void> discover({dynamic hint}) =>
    RustLib.instance.api.discover(hint: hint);

Future<void> accept({required bool isAccept, dynamic hint}) =>
    RustLib.instance.api.accept(isAccept: isAccept, hint: hint);

Stream<Progress> listenProgress({dynamic hint}) =>
    RustLib.instance.api.listenProgress(hint: hint);

Stream<DiscoverState> listenDiscover({dynamic hint}) =>
    RustLib.instance.api.listenDiscover(hint: hint);

Stream<ServerStatus> serverStatus({dynamic hint}) =>
    RustLib.instance.api.serverStatus(hint: hint);

class DeviceConfig {
  final String alias;
  final String fingerprint;
  final String deviceModel;
  final String deviceType;
  final String storePath;

  const DeviceConfig({
    required this.alias,
    required this.fingerprint,
    required this.deviceModel,
    required this.deviceType,
    required this.storePath,
  });

  @override
  int get hashCode =>
      alias.hashCode ^
      fingerprint.hashCode ^
      deviceModel.hashCode ^
      deviceType.hashCode ^
      storePath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DeviceConfig &&
          runtimeType == other.runtimeType &&
          alias == other.alias &&
          fingerprint == other.fingerprint &&
          deviceModel == other.deviceModel &&
          deviceType == other.deviceType &&
          storePath == other.storePath;
}

@freezed
sealed class DiscoverState with _$DiscoverState {
  const factory DiscoverState.discovering(
    List<DeviceInfo> field0,
  ) = DiscoverState_Discovering;
  const factory DiscoverState.done() = DiscoverState_Done;
}

class LogEntry {
  final int timeMillis;
  final int level;
  final String tag;
  final String msg;

  const LogEntry({
    required this.timeMillis,
    required this.level,
    required this.tag,
    required this.msg,
  });

  @override
  int get hashCode =>
      timeMillis.hashCode ^ level.hashCode ^ tag.hashCode ^ msg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogEntry &&
          runtimeType == other.runtimeType &&
          timeMillis == other.timeMillis &&
          level == other.level &&
          tag == other.tag &&
          msg == other.msg;
}

class ServerConfig {
  final String multicastAddr;
  final int port;
  final String protocol;
  final bool download;
  final bool announcement;
  final bool announce;

  const ServerConfig({
    required this.multicastAddr,
    required this.port,
    required this.protocol,
    required this.download,
    required this.announcement,
    required this.announce,
  });

  @override
  int get hashCode =>
      multicastAddr.hashCode ^
      port.hashCode ^
      protocol.hashCode ^
      download.hashCode ^
      announcement.hashCode ^
      announce.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServerConfig &&
          runtimeType == other.runtimeType &&
          multicastAddr == other.multicastAddr &&
          port == other.port &&
          protocol == other.protocol &&
          download == other.download &&
          announcement == other.announcement &&
          announce == other.announce;
}

enum ServerStatus {
  starting,
  started,
  stopping,
  stopped,
}
